model.matrix(~as.factor(A))
mean(y)
lm2=lm(y~Xa)
lm2
aggregate(y,by=list(A))
aggregate(y,by=list(A),mean)
library(glm)
?glm
require(utils) # for str#
nf <- gaussian()  # Normal family#
nf#
str(nf)
4.1948       -2.0028
4.1948        -0.5738
lm1=lm(y~-1+Xa+Xb)
lm1
aggregate(y,by=list(A),mean)
2.5930 -2.191910
4.0221-0.40109
4.5959--0.40109
load("/Users/lianlian/Dropbox/work/arvalisGxE/testData/balance/dat.rda")
load("/Users/lianlian/Dropbox/work/arvalisGxE/testData/balance/LSvalue.rda")
LSvalue$g
LSvalue$h
head(dat)
lm1=lm(y~-1+factor(IDE)+factor(IDL))
lm1=lm(y~-1+factor(IDE)+factor(IDL),data=dat)
lm1
coef(lm1)
cor(coef(lm1)[1:10],LSvalue$h)
LSvalue$h+mean(dat$y)
plot(LSvalue$h,coef(lm1)[1:10])
coef(lm1)[1:10]-LSvalue$h
aggregate(dat$y,by=list(dat$IDE),mean)
dim(dat)
lm1=lm(y~-1+Xa+Xb)
lm1
aggregate(y,by=list(A),mean)[,2]-coeff(lm1)[1:3]
aggregate(y,by=list(A),mean)[,2]-coef(lm1)[1:3]
aggregate(y,by=list(B),mean)[,2]
aggregate(y,by=list(B),mean)[,2]-mean(y)
?lmer
library(lme4)
?lmer
sleepstudy
head(sleepstudy)
lmer(Reaction ~ Days + (|Days/ Subject), sleepstudy))
lmer(Reaction ~ Days + (1|Days/ Subject), sleepstudy))
lmer(Reaction ~ Days + (1|Days/ Subject), sleepstudy)
A
V
B
lmer(Reaction ~ as.factor(A) + as.factor(B)+(1|as.factor(A)/as.factor(B)), sleepstudy)
lmer(y~ as.factor(A) + as.factor(B)+(1|as.factor(A)/as.factor(B)))
lmer(y~ as.factor(A) +(1|as.factor(A)/as.factor(B)))
lmer(y~ as.factor(A) +(1|as.factor(A):as.factor(B)))
A=rep(a:c,each=20)#
B=rep(a:b,times=30)
A=rep(letters[1:3],each=20)#
B=rep(letters[1:2]times=30)
A
B=rep(letters[1:2],times=30)
lmer(y~ A +(1|A/B))
lmer(y~ A +(1|A:B))
set.seed(30629)
rnorm(10)
set.seed(30629)
rnorm(10)
colnames(H)=rownames(H)=unique(ENV)
fit.optim=function(par,fn,logVar=T,tauRel=NULL, optimizer="bobyqa",...){#
	namesPar=names(par)#
if(is.null(namesPar)){stop("par must have names")}#
  if(optimizer=="optim"){#
  fit<-optim(par=par,fn=fn,logVar=logVar,tauRel=tauRel, ...)#
  }#
  #The default fitting algorithm in lmer function#
  ##
  if(optimizer=="bobyqa"){#
  tmpfit<-bobyqa(par=par,fn=fn,logVar=logVar,tauRel=tauRel, ...) #
  fit=list()#
  fit$par=tmpfit$par#
  fit$value=tmpfit$fval#
  fit$counts=tmpfit$feval#
  fit$convergence=tmpfit$ierr#
  fit$message=tmpfit$msg#
  }#
  if(is.na(fit$value)){#
  stop("objective function returned NA, please check input values")#
  }#
  names(fit$par)=namesPar#
  Var=fit$par#
  Var=get_tau(Var,logVar,tauRel)#
  for(i in 1:length(Var)){#
  	#var_e,taud,tauw#
  	assign(names(Var)[i],Var[[i]])#
  } #
  fit$outVar=Var#
  fit$loglik=-1/2*fit$value#
  if(logVar==T){fit$par=exp(fit$par)}#
  return(fit)#
#
}#
#
 get_tau=function(Var,logVar,tauRel){#
  if(logVar==T){#
    Var=exp(Var)#
  }#
#
  for(i in 1:length(Var)){#
  	assign(names(Var)[i],Var[i])#
  }#
  namesPar=names(Var)#
  if(any(!gsub("\\d*","",namesPar) %in% c("var_e","taud","tauw"))){#
  	stop("Var names must be var_e, taud, or tauwD")#
  }#
  if(is.null(tauRel)){#
  	names.tauw=grep("tauw",namesPar,value=T)#
  	  	} else{#
  	for(i in 1:length(tauRel)){#
  		eval(parse(text=tauRel[[i]]))#
  	}  		#
   	split.tau=strsplit(tauRel,split="=")#
   	names.tauw=grep("tauw",c(unlist(split.tau),namesPar),value=T)#
   	names.tauw=gsub(".*(tauw\\d+).*","\\1",names.tauw)#
  	names.tauw=unique(names.tauw)#
  }#
  if(length(names.tauw)>0){	#
  index.tauw=as.numeric(gsub("tauw(\\d+)","\\1",names.tauw))#
  names.tauw=names.tauw[order(index.tauw)]#
  tauw=vector()#
  for(i in 1:length(names.tauw)){#
  	tauw[i]=get(names.tauw[i])#
  }#
  names(tauw)=names(tauw)#
  }else tauw=NULL#
  Var=list(var_e=var_e,taud=taud,tauw=tauw)#
  return(Var)#
  }#
 getDL.XYZ=function(var_e,taud,tauw=NULL,eigenZd,X,y,W=NULL,kw=NULL,Zt=NULL){#
	n=length(y)#
 	U1=eigenZd$U1#
	d1=eigenZd$d1#
	tXX=crossprod(X)#
	tU1y=crossprod(U1,y)#
 	tU1X=crossprod(U1,X)#
 	tXy=crossprod(X,y)#
 	tyy=sum(y^2) 	#
 	if(!is.null(W)){#
 		tU1W=crossprod(U1,W)#
 		tXW=crossprod(X,W)#
 		tWW=crossprod(W)#
 		tWy=crossprod(W,y)#
 	}else{#
 		tU1W=tXW=tWW=tWy=NULL#
 	}#
 	if(!is.null(Zt)){#
 		tZtZt=crossprod(Zt)#
 		tU1Zt=crossprod(U1,Zt)#
 		tXZt=crossprod(X,Zt)#
 		tyZt=crossprod(y,Zt)#
 		if(!is.null(W)){#
 			tWZt=crossprod(W,Zt)#
 		}else{tWZt=NULL}	#
 	}else{#
 		tZtZt=tU1Zt=tXZt=tyZt=NULL#
 	}#
 	 out=getDL(var_e,taud,d1=d1,n=n,tU1y=tU1y,tU1X=tU1X,tXX=tXX,tXy=tXy,tyy=tyy,tauw=tauw,kw=kw,tU1W=tU1W,tXW=tXW,tWW=tWW,tWy=tWy,tZtZt=tZtZt,tU1Zt=tU1Zt,tXZt=tXZt,tyZt=tyZt,tWZt=tWZt,getQ=F,getS=F,getNeg2Log=T,REML=T)#
 return(out)	#
 }#
neg2Log=function(Var,tU1y,tU1X,tXX,tXy,tyy,d1,n,tU1W=NULL,tXW=NULL,tWW=NULL,tWy=NULL,kw=NULL,logVar=T,tauRel=NULL,REML=T){#
  #d1 and U1 from d1=svd(Zd)$d^2, U1=svd(Zd)$u #
  Var=get_tau(Var,logVar,tauRel)#
  for(i in 1:length(Var)){#
  	assign(names(Var)[i],Var[[i]])#
  } #
  out<-getDL(var_e=var_e,taud=taud,d1=d1,n=n,tU1y=tU1y,tU1X=tU1X,tXX=tXX,tXy=tXy,tyy=tyy,tauw=tauw,kw=kw,tU1W=tU1W,tXW=tXW,tWW=tWW,tWy=tWy,getNeg2Log=T,REML=REML)#
  return(out)#
 }#
getDL=function(var_e,taud,d1,n,tU1y,tU1X,tXX,tXy,tyy,tauw=NULL,kw=NULL,tU1W=NULL,tXW=NULL,tWW=NULL,tWy=NULL,tZtZt=NULL,tU1Zt=NULL,tXZt=NULL,tyZt=NULL,tWZt=NULL,getQ=F,getS=F,getNeg2Log,REML=T)#
{	if(is.null(tauw))tauw=NA#
	if(is.null(kw))kw=NA#
	if(is.null(tU1W))tU1W=NA#
	if(is.null(tXW))tXW=NA#
	if(is.null(tWW))tWW=NA#
	if(is.null(tWy))tWy=NA#
	if(is.null(tZtZt))tZtZt=NA#
	if(is.null(tU1Zt))tU1Zt=NA#
	if(is.null(tXZt))tXZt=NA#
	if(is.null(tyZt))tyZt=NA#
	if(is.null(tWZt))tWZt=NA#
	getQ=as.integer(getQ)#
	getS=as.integer(getS)#
	getNeg2Log=as.integer(getNeg2Log)#
	REML=as.integer(REML)#
	out<-.Call("C_getDL",var_e,taud, d1,n,tU1y,tU1X,tXX,tXy,tyy,tauw,kw,tU1W,tXW,tWW,tWy,tZtZt,tU1Zt,tXZt,tyZt,tWZt,getQ,getS,getNeg2Log,REML) #
	return(out)	#
}#
getEigenZd=function(Kd=NULL,Zd=NULL,precision=1e-5){#
  out=list()#
  if(!is.null(Kd) & !is.null(Zd)) stop("Only use one of Kd or Zd")#
  if(!is.null(Zd)){#
  	if(any(is.na(Zd))){#
  		Zd=meanImpute(Zd)#
  	}#
  	if(nrow(Zd)<=ncol(Zd)) {#
  		Kd=tcrossprod(scale(Zd,T,F))#
  	    eigenKd=eigen(Kd,symmetric=T)#
    	U1=eigenKd$vectors#
    	d1=eigenKd$values	#
  	}else{#
  	svdZd=svd(Zd,nv=0)#
    U1=svdZd$u#
    d1=svdZd$d^2 ###Do not forget d^2!!!#
  	}#
  }	else{#
    eigenKd=eigen(Kd,symmetric=T)#
    U1=eigenKd$vectors#
    d1=eigenKd$values	#
  }#
  wh0=which(d1<precision)#
  if(length(wh0>0)){#
  	d1=d1[-wh0] #
  	U1=U1[,-wh0]#
 	}#
  out$d1=d1#
  out$U1=U1#
  return(out)#
}#
#
#A wrapper for testZ#
testWindow=function(y,X,Zt,eigenG=NULL,W=NULL,removeZtFromG=F,optimizer='bobyqa'){#
	##optimizing functions for solving variance components with REML. Either "bobyqa" or "optim",default is 'bobyqa', #
		#W should be a list of all other incidence matrix for random effects #
	#eigenG is produced by eigenZd#
	if(removeZtFromG==T){#
	W=c(W,list(Zt))#
	nw=length(W)#
	out=testZ(y,X,eigenZd=eigenG,Zt=Zt,W=W,tauRel=paste("tauw",nw,"=-taud",sep=""),windowtest=c("Score","SKAT"),optimizer=optimizer)#
	}else{#
	out=testZ(y,X,eigenZd=eigenG,Zt=Zt,W=W,tauRel=NULL,windowtest=c("Score","SKAT"),optimizer=optimizer)	#
	}#
	return(out)#
}#
testZ=function(y,X,W=NULL,tauRel=NULL,Zt,eigenZd,windowtest,tU1X=NULL,tU1y=NULL,tXX=NULL,tXy=NULL,tyy=NULL,logVar=T,optimizer="bobyqa"){#
    #check input#
    X=as.matrix(X)#
	Zt=as.matrix(Zt)#
	if(any(is.na(y))){#
  		#optim function will report not being able to evalue function at intial values when there is NA#
  		if((!is.null(tU1X))|(!is.null(tU1y))|!is.null(tXX)|(!is.null(tXy))|(!is.null(tyy))){#
  			stop("there should be no missing values when tU1X, tU1y, tXX, tXy or tyy is supplied")#
  		}#
	whNAy=which(is.na(y))#
	y=y[-whNAy]#
	X=X[-whNAy,,drop=F]#
	Zt=Zt[-whNAy,,drop=F]#
    eigenZd$U1=eigenZd$U1[-whNAy,]#
    }else{#
      	whNAy=NA#
    }#
	out=list()#
  	#Null model with no random effects#
  	#classical SKAT test#
 	 if(!is.null(windowtest)){#
 		if(is.null(eigenZd)){#
  			mod=lm(y~-1+X)#
  			resid=residuals(mod)#
  			s2 = summary(mod)$sigma**2#
  			Q=sum((t(resid)%*%(Zt))^2)/s2/2#
  			W.1=t(Zt) %*% Zt - (t(Zt) %*%X)%*%solve(t(X)%*%X)%*% (t(X) %*% Zt )#
			lambda=eigen(W.1/2,symmetric=TRUE, only.values = TRUE)$values#
			lambda1=lambda#
			IDX1<-which(lambda >= 0)#
			# eigenvalue bigger than mean(lambda1[IDX1])/100000 #
			IDX2<-which(lambda1 > mean(lambda1[IDX1])/100000)#
			lambda<-lambda1[IDX2]#
			out$p.SKAT<-Get_PValue.Lambda(lambda, Q)   #
			out$p.Score=NA#
  			return(out)#
  		}#
  }#
  #logVar, paramterize variance components with log when using REML to restrict variance component to be larger than 0.#
  d1=eigenZd$d1#
  U1=eigenZd$U1#
  if(is.null(tU1X)) tU1X=crossprod(U1,X)#
  if(is.null(tU1y)) tU1y=crossprod(U1,y)#
  n=length(y)#
  nd=length(d1)#
  if(nd<n){#
  if(is.null(tXy)) tXy=crossprod(X,y)#
  if(is.null(tXX)) tXX=crossprod(X)#
  if(is.null(tyy)) tyy=sum(y^2)#
  }#
  if(!is.null(W)){#
  	if(!is.list(W)){stop("W must be a list of all other random effect incidence matrix")}#
   kw=sapply(W,ncol)#
   nw=length(kw)#
   W=do.call(cbind,W)#
    if(sum(kw)!=ncol(W))stop("sum of kw should be equal to the number of columns in W")#
   #remove NA values#
   if(length(whNAy)>0){W=W[-whNAy,,drop=F]} #
    tauw=rep(0,nw)#
    tU1W=crossprod(U1,W)#
    tXW=crossprod(X,W)#
    tWW=crossprod(W,W)#
    tWy=crossprod(W,y)#
    if(!is.null(windowtest)){tWZt=crossprod(W,Zt)}else{tWZt=NULL}#
  }else {#
    nw=0#
    tauw=NULL#
    tU1W=NULL#
    tXW=NULL#
    tWW=NULL#
    tWy=NULL#
    tWZt=NULL#
  }#
  if(!is.null(windowtest)){#
  tU1Zt=crossprod(U1,Zt)#
  tZty=crossprod(Zt,y)#
  tyZt=t(tZty)#
  tXZt=crossprod(X,Zt)#
  tZtZt=crossprod(Zt,Zt)	#
  }#
  ##test with low rank Zh	#
  namesPar=c("var_e","taud")#
  if(nw>0){#
  	namesPar=c("var_e","taud",paste("tauw",c(1:nw),sep=""))#
  	if(!is.null(tauRel)){#
  		splittau=strsplit(tauRel,split="=")#
  		unlist.splittau=unlist(splittau)#
  		#only the independent Var need to be positive if using logVar#
  		#exp transformation will only be applied to par, not the dependent var#
  		#if(any(grepl("-[[:punct:][:digit:]]*tau",unlist.splittau))){if(logVar==T)stop("logVar must be set to False when the tau values are of different signs")}#
  		n.Rel=length(splittau)#
  		if(length(unlist.splittau)>2*length(splittau)) stop("Every equation must contain only one relationship")#
  		#strip off the digits, decimal point (.) and +,-,*,/#
  		if(any(!(gsub("([[:digit:][:punct:]e]+)","",unlist.splittau)%in% c("taud","tauw","")))){#
  			stop("in tauRel, must only specify taud or tauwD, where D is any integer less or equal to the number of W matrix")#
  			}#
  		left.tau=gsub(".*(tau[wd]{1}\\d*).*","\\1",sapply(splittau,function(a)a[1]))#
        right.tau=gsub(".*(tau[wd]{1}\\d*).*","\\1",sapply(splittau,function(a)a[2]))#
        if(any(duplicated(left.tau))){stop("duplicated terms on the lest side of equations")}#
        if(length(intersect(right.tau,left.tau))>0){stop("one variable can only appear on one side of equation")}#
  		for(i in 1:length(splittau)){#
  			splittau.i=gsub(".*(tau[dw]{1}\\d*).*","\\1",splittau[[i]])#
  			n.split=length(splittau.i)#
  			##only keep the last tau from relationship equation#
  			namesPar=setdiff(namesPar,splittau.i[-n.split])#
  		}#
  		}#
  	}#
  par=rep(0.5,length(namesPar))#
  names(par)=namesPar	#
  fit0=fit.optim(par=par,fn=neg2Log,logVar=logVar,d1=d1,n=n,tU1y=tU1y,tU1X=tU1X,tXX=tXX,tXy=tXy,tyy=tyy,tU1W=tU1W,tXW=tXW,tWW=tWW,tWy=tWy,kw=kw,tauRel=tauRel,optimizer=optimizer)#
  out$fit0=fit0#
  ##SKAT test or LR test#
  if("SKAT" %in% windowtest | "Score" %in% windowtest){#
    var_e=fit0$outVar$var_e#
    taud=fit0$outVar$taud#
    if(nw>0)tauw=fit0$outVar$tauw#
    getQ=("SKAT" %in% windowtest)#
    getS= ("Score" %in% windowtest)#
    Qdis=getDL(var_e,taud=taud,tauw=tauw,tU1y=tU1y,tU1X=tU1X,tXX=tXX,tXy=tXy,tyy=tyy,d1=d1,n=n,kw=kw,tU1W=tU1W,tXW=tXW,tWW=tWW,tWy=tWy,getQ=getQ,getS=getS,tZtZt=tZtZt,tU1Zt=tU1Zt,tXZt=tXZt,tyZt=tyZt,tWZt=tWZt)	#
    if("SKAT" %in% windowtest){#
      Q=Qdis$Q#
      lambda=Qdis$lambda      #
      lambda1=lambda#
      IDX1<-which(lambda >= 0)#
      #eigenvalue bigger than mean(lambda1[IDX1])/100000 #
      IDX2<-which(lambda1 > mean(lambda1[IDX1])/100000)#
      lambda<-lambda1[IDX2]#
      p.value<-Get_PValue.Lambda(lambda,Q) #
      out$p.SKAT=p.value#
      out$Q=Q#
    }#
    #Score test#
    if("Score" %in% windowtest){#
      S=Qdis$S#
      sdS=Qdis$sdS	#
      out$Score=S#
      out$sdScore=sdS#
      out$p.Score=pnorm(S/sdS,lower.tail=F)#
    }#
  }#
 return(out)  #
}
a=matrix(1:10)
a
class(a)
?read.table
?readline
?read.table
library(BGLR)
data(mouse)
data(wheat)
dim(wheat.X)
library(rrBLUP)
data()
install.packages("rrBLUP")
install.packages("rrBLUP")
library(rrBLUP)
rrBLUP()
rrblup
head(wheat.Y)
ls()
?mixed.solve
mixed.solve(y=wheat.Y[,1],Z=wheat.X)
u=mixed.solve(y=wheat.Y[,1],Z=wheat.X)$u
which.min(u)
head(wheat.Y)
CV=sample(1:10,size=599,replace=T)
CV
dim(wheat.X)
ncV=10#
Z=wheat.X[,1:10]#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
set.seed(1)#
CV=sample(1:ncV,size=n,replace=T)#
#
corr=rep(0,nMar)#
while(nMar>0){#
u=rep(0,nMar)#
corrk=0#
for(i in 1:10){#
	traini=which(CV!=i)#
	u=u+mixed.solve(y=y[traini],Z=Z[traini,])$u/ncV#
    corrk=corrk+cor(y[-traini],Z[-traini,]%*%u)/ncV#
  }#
  corr[k]=corr[k]#
  Z=Z[,-which.min(u)]#
  nMar=ncol(Z)#
 }
ncV=10#
Z=wheat.X[,1:10]#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
set.seed(1)#
CV=sample(1:ncV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
for(i in 1:10){#
	traini=which(CV!=i)#
	u=u+mixed.solve(y=y[traini],Z=Z[traini,])$u/ncV#
    corrk=corrk+cor(y[-traini],Z[-traini,]%*%u)/ncV#
  }#
  corr[k]=corrk#
  Z=Z[,-which.min(u)]#
  k=ncol(Z)#
 }
k
corr
length(corr)
nMar
which.min(u)
dim(Z)
class(Z)
corr
plot(corr~c(1:10))
Z=wheat.X[,1,drop=F]
ncol(Z)
Z=Z[,-1]
dim(Z)
ncol(Z)
Z=wheat.X[,1,drop=F]
dim(Z)
Z=Z[,-1,drop=F]
dim(Z)
Z
class(Z)
ncol(Z)
ncV=10#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
set.seed(1)#
CV=sample(1:ncV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
for(i in 1:10){#
	traini=which(CV!=i)#
	u=u+mixed.solve(y=y[traini],Z=Z[traini,])$u/ncV#
    corrk=corrk+cor(y[-traini],Z[-traini,]%*%u)/ncV#
  }#
  corr[k]=corrk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
 }
nCV=5#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	u=u+mixed.solve(y=y[traini],Z=Z[traini,])$u/nCV#
    corrk=corrk+cor(y[-traini],Z[-traini,]%*%u)/nCV#
  }#
  corr[k]=corrk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
dim(Z)
length(u)
dim(Z[-traini,])
dim(Z[-traini,,drop=F])
plot(corr~c(nMar:1))
plot(corr~c(1:nMar))
k
u
corrk=corrk+cor(y[-traini],Z[-traini,drop=F]%*%u)/nCV
dim(Z)
length(u)
nCV=5#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,drop=F]%*%as.matrix(u.i)/nCV#
  }#
  corr[k]=corrk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
nCV=5#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,drop=F]%*%as.matrix(u.i))/nCV#
  }#
  corr[k]=corrk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
n
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(n.TV,1:n)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV,]#
Z=Z[whTV,]#
y=y[whTV,]#
#
Z.test#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
corr.test=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
corr.testk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,drop=F]%*%as.matrix(ui))/nCV#
	corr.testk=corr.testk+cor(y.test,Z.test%*%as.matrix(ui))/nCV#
  }#
  corr[k]=corrk#
  corr.test[k]=corr.testk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(n.TV,1:n)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV,]#
Z=Z[whTV,]#
y=y[whTV,]#
n=nrow(Z)#
#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
corr.test=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
corr.testk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,drop=F]%*%as.matrix(ui))/nCV#
	corr.testk=corr.testk+cor(y.test,Z.test%*%as.matrix(ui))/nCV#
  }#
  corr[k]=corrk#
  corr.test[k]=corr.testk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
n
whTV
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(1:n,n.TV)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV,]#
Z=Z[whTV,]#
y=y[whTV,]#
n=nrow(Z)#
#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
corr.test=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
corr.testk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,drop=F]%*%as.matrix(ui))/nCV#
	corr.testk=corr.testk+cor(y.test,Z.test%*%as.matrix(ui))/nCV#
  }#
  corr[k]=corrk#
  corr.test[k]=corr.testk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
dim(Z)
dim(Z.test)
length(ui)
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(1:n,n.TV)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV,]#
Z=Z[whTV,]#
y=y[whTV,]#
n=nrow(Z)#
#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
corr.test=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
corr.testk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,,drop=F]%*%as.matrix(ui))/nCV#
	corr.testk=corr.testk+cor(y.test,Z.test%*%as.matrix(ui))/nCV#
  }#
  corr[k]=corrk#
  corr.test[k]=corr.testk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
dim(Z)
dim(Z[-traini, , drop = F] )
length(CV)
which(CV!=i)
i
which(CV==i)
traini
length(ui)
dim(as.matrix(ui))
dim(Z[-traini,,drop=F])
Z[-traini,,drop=F]%*%as.matrix(ui)
cor(y[-traini],Z[-traini,,drop=F]%*%as.matrix(ui))
length(y[-traini])
length(y)
length(whTV)
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(1:n,n.TV)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV,]#
Z=Z[whTV,]#
y=y[whTV,]#
n=nrow(Z)
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(1:n,n.TV)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV]#
Z=Z[whTV,]#
y=y[whTV]#
n=nrow(Z)
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
corr.test=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
corr.testk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,,drop=F]%*%as.matrix(ui))/nCV#
	corr.testk=corr.testk+cor(y.test,Z.test%*%as.matrix(ui))/nCV#
  }#
  corr[k]=corrk#
  corr.test[k]=corr.testk#
  Z=Z[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
dim(Z.test)
as.matrix(ui)
dim(as.matrix(ui))
nCV=5#
p.TV=2/3  ##proportion used for train and vali#
Z=wheat.X#
y=wheat.Y[,1]#
nMar=ncol(Z)#
n=nrow(Z)#
n.TV=round(n*p.TV)#
whTV=sample(1:n,n.TV)#
n.test=n-n.TV#
Z.test=Z[-whTV,]  #proprotion used for test.#
y.test=y[-whTV]#
Z=Z[whTV,]#
y=y[whTV]#
n=nrow(Z)#
#
set.seed(1)#
CV=sample(1:nCV,size=n,replace=T)#
k=nMar #
corr=rep(0,k)#
corr.test=rep(0,k)#
while(k>0){#
u=rep(0,k)#
corrk=0#
corr.testk=0#
for(i in 1:nCV){#
	traini=which(CV!=i)#
	ui=mixed.solve(y=y[traini],Z=Z[traini,,drop=F])$u#
	u=u+ui/nCV#
	corrk=corrk+cor(y[-traini],Z[-traini,,drop=F]%*%as.matrix(ui))/nCV#
	corr.testk=corr.testk+cor(y.test,Z.test%*%as.matrix(ui))/nCV#
  }#
  corr[k]=corrk#
  corr.test[k]=corr.testk#
  Z=Z[,-which.min(u),drop=F]#
  Z.test=Z.test[,-which.min(u),drop=F]#
  k=ncol(Z)#
  cat(k,"\n")#
 }
plot(corrk~c(1:nMar))
plot(corr~c(1:nMar))
lines(corr.test~c(1:nMar),col="red")
plot(corrk.test~c(1:nMar),y.min=min(corr.test),y.max=max(corr))
plot(corr.test~c(1:nMar),ylim=c(min(corr.test),max(corr))
)
lines(corr~c(1:nMar),col="red")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FW/R/lmFW.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FW/R/lmFW.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FW/R/lmFW.R")
FWdir="~/Dropbox/work/arvalisGxE/manuscript/FW"#
setwd(file.path(FWdir,"src"))#
dyn.load("C_GibbsFW.so")#
sourceDir <- function(path, trace = TRUE, ...) {#
    for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {#
       if(trace) cat(nm,":")#
       source(file.path(path, nm), ...)#
       if(trace) cat("\n")#
    }#
 }#
#
sourceDir(file.path(FWdir,"R"))#
library(coda)#
#
load("~/Dropbox/work/arvalisGxE/wheat/wheatAll.rda")#
#
attach(wheat.Y50)#
lm1=FW(y,VAR,ENV)#
#
H=diag(1,4)#
colnames(H)=rownames(H)=unique(ENV)#
lm1=FW(y,VAR,ENV,A=wheat.G)#
lm2=FW(y,VAR,ENV,A=wheat.G,H=H)#
cor(lm1$y,lm1$yhat)#
cor(lm2$y,lm2$yhat)#
#
whichNa=which(is.na(yNA))#
lm1=FW(yNA,VAR,ENV,A=wheat.G,seed=2)#
cor(lm1$yhat[whichNa],y[whichNa])
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FW/R/GibbsFW.R")
FWdir="~/Dropbox/work/arvalisGxE/manuscript/FW"#
setwd(file.path(FWdir,"src"))#
dyn.load("C_GibbsFW.so")#
sourceDir <- function(path, trace = TRUE, ...) {#
    for (nm in list.files(path, pattern = "[.][RrSsQq]$")) {#
       if(trace) cat(nm,":")#
       source(file.path(path, nm), ...)#
       if(trace) cat("\n")#
    }#
 }#
#
sourceDir(file.path(FWdir,"R"))#
library(coda)#
#
load("~/Dropbox/work/arvalisGxE/wheat/wheatAll.rda")#
#
attach(wheat.Y50)#
lm1=FW(y,VAR,ENV)#
#
H=diag(1,4)#
colnames(H)=rownames(H)=unique(ENV)#
lm1=FW(y,VAR,ENV,A=wheat.G)#
lm2=FW(y,VAR,ENV,A=wheat.G,H=H)#
cor(lm1$y,lm1$yhat)#
cor(lm2$y,lm2$yhat)#
#
whichNa=which(is.na(yNA))#
lm1=FW(yNA,VAR,ENV,A=wheat.G,seed=2)#
cor(lm1$yhat[whichNa],y[whichNa])
lm1$h
lm1$mu
names(lm1)
head(lm1$yhat)
write.table(lm1$yhat[1:10],file="clipboard")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/GibbsFWh0.R")
?scale
scale(c(1,2,3,NA),T,F)
?scale
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/initialize.jags.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFW.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFW.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFW.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFW.R")
load("/Users/lianlian/Dropbox/github/lian0090.github.io/FWd/jags.m.rda")
jags.m
library(rjags)
parameters<-c("mu","g","b","h","var_g","var_b","var_h","var_e")
parameters<-c("mu","g[1]","b[1]","h[1]","var_g","var_b","var_h","var_e")
samps<-coda.samples(jags.m,parameters,n.iter=nIter,thin=thin)
load("/Users/lianlian/Dropbox/github/lian0090.github.io/FWd/jags_samps.rda")
ls()
load("/Users/lianlian/Dropbox/github/lian0090.github.io/FWd/samps.rda")
plot(samps[,c("h1","h2")])
plot(samps[,c("h[1]","h[2]")])
plot(samps[,c("mu","h[1]","h[2]")])
plot(samps[,c("mu","h[1]","h[2]")],density=F)
plot(samps[,c("mu","h[1]","h[2]")],density=F,burnIn=3000,thin=5)
load("/Users/lianlian/Dropbox/github/lian0090.github.io/FWd/samps.rda")
load("/Users/lianlian/Dropbox/github/lian0090.github.io/FWd/samps.rda")
plot(samps)
plot(samps[601:1000,c("mu","h[1]","h[2]")])
plot(samps[,c("mu","h[1]","h[2]")])
for(i in 1:length(samps)){samps[[i]]=samps[[i]][-1:600,]}
for(i in 1:length(samps)){samps[[i]]=samps[[i]][-c(1:600),]}
plot(samps)
for(i in 1:length(samps)){samps[[i]]=mcmc.list(samps[[i]])}
?jags.samples
class(samps)
for(i in 1:length(samps)){samps[[i]]=mcmc.list(samps[[i]])}
for(i in 1:length(samps)){samps[[i]]=mcmc.list(samps[[i]])}
?mcmc.list
for(i in 1:length(samps)){samps[[i]]=mcmc(samps[[i]])}
plot(samps)
dim(samps[[1]])
?mcmc
for(i in 1:length(samps)){samps[[i]]=as.mcmc(samps[[i]],start=3001,end=5000,thin=5)}
plot(samps)
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFWhmu.R")
load("/Users/lianlian/Dropbox/github/lian0090.github.io/FWd/jags.m.rda")
jags.m
levelsb=rep(factor(1:4),each=10)
X=X[,c(1,4,2,3,5)]
eiG=eigen(G)
eiX=eigen(X)
U[1:3,1:3]=eiG$vectors
library(rrBLUP)
mixed.solve()
i=1
CV=sample(c(1:5),size=n,replace=T)#
corr=matrix(nrow=5,ncol=3)
whichNa=which(CV==i)#
yNA=y[-whichNa]#
#
out=mixed.solve(y=yNA,Z=Z)
out=mixed.solve(y=y[-whichNa],Z=Z[-whichNa])
out=mixed.solve(y=y[-whichNa],Z=Z[-whichNa,])
dim(Z[-whichNa,])
Z=model.matrix(~-1+levelsb)
load("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/samps.rda")
plot(samps)
plot(samps,ask=T,density=F)
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFWhmudh.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFWhmudh.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFWhmu copy.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/jagsFWhmu copy.R")
source("/Users/lianlian/Dropbox/work/arvalisGxE/manuscript/FWd/R/GibbsFWh0.R")
source("/Users/lianlian/Dropbox/Public/FWd/FWd/R/jagsFWhmudh2.R")
?assign
